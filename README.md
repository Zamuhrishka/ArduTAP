![Build with PlatformIO](https://img.shields.io/badge/build%20with-PlatformIO-orange?logo=data%3Aimage%2Fsvg%2Bxml%3Bbase64%2CPHN2ZyB3aWR0aD0iMjUwMCIgaGVpZ2h0PSIyNTAwIiB2aWV3Qm94PSIwIDAgMjU2IDI1NiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+PHBhdGggZD0iTTEyOCAwQzkzLjgxIDAgNjEuNjY2IDEzLjMxNCAzNy40OSAzNy40OSAxMy4zMTQgNjEuNjY2IDAgOTMuODEgMCAxMjhjMCAzNC4xOSAxMy4zMTQgNjYuMzM0IDM3LjQ5IDkwLjUxQzYxLjY2NiAyNDIuNjg2IDkzLjgxIDI1NiAxMjggMjU2YzM0LjE5IDAgNjYuMzM0LTEzLjMxNCA5MC41MS0zNy40OUMyNDIuNjg2IDE5NC4zMzQgMjU2IDE2Mi4xOSAyNTYgMTI4YzAtMzQuMTktMTMuMzE0LTY2LjMzNC0zNy40OS05MC41MUMxOTQuMzM0IDEzLjMxNCAxNjIuMTkgMCAxMjggMCIgZmlsbD0iI0ZGN0YwMCIvPjxwYXRoIGQ9Ik0yNDkuMzg2IDEyOGMwIDY3LjA0LTU0LjM0NyAxMjEuMzg2LTEyMS4zODYgMTIxLjM4NkM2MC45NiAyNDkuMzg2IDYuNjEzIDE5NS4wNCA2LjYxMyAxMjggNi42MTMgNjAuOTYgNjAuOTYgNi42MTQgMTI4IDYuNjE0YzY3LjA0IDAgMTIxLjM4NiA1NC4zNDYgMTIxLjM4NiAxMjEuMzg2IiBmaWxsPSIjRkZGIi8+PHBhdGggZD0iTTE2MC44NjkgNzQuMDYybDUuMTQ1LTE4LjUzN2M1LjI2NC0uNDcgOS4zOTItNC44ODYgOS4zOTItMTAuMjczIDAtNS43LTQuNjItMTAuMzItMTAuMzItMTAuMzJzLTEwLjMyIDQuNjItMTAuMzIgMTAuMzJjMCAzLjc1NSAyLjAxMyA3LjAzIDUuMDEgOC44MzdsLTUuMDUgMTguMTk1Yy0xNC40MzctMy42Ny0yNi42MjUtMy4zOS0yNi42MjUtMy4zOWwtMi4yNTggMS4wMXYxNDAuODcybDIuMjU4Ljc1M2MxMy42MTQgMCA3My4xNzctNDEuMTMzIDczLjMyMy04NS4yNyAwLTMxLjYyNC0yMS4wMjMtNDUuODI1LTQwLjU1NS01Mi4xOTd6TTE0Ni41MyAxNjQuOGMtMTEuNjE3LTE4LjU1Ny02LjcwNi02MS43NTEgMjMuNjQzLTY3LjkyNSA4LjMyLTEuMzMzIDE4LjUwOSA0LjEzNCAyMS41MSAxNi4yNzkgNy41ODIgMjUuNzY2LTM3LjAxNSA2MS44NDUtNDUuMTUzIDUxLjY0NnptMTguMjE2LTM5Ljc1MmE5LjM5OSA5LjM5OSAwIDAgMC05LjM5OSA5LjM5OSA5LjM5OSA5LjM5OSAwIDAgMCA5LjQgOS4zOTkgOS4zOTkgOS4zOTkgMCAwIDAgOS4zOTgtOS40IDkuMzk5IDkuMzk5IDAgMCAwLTkuMzk5LTkuMzk4em0yLjgxIDguNjcyYTIuMzc0IDIuMzc0IDAgMSAxIDAtNC43NDkgMi4zNzQgMi4zNzQgMCAwIDEgMCA0Ljc0OXoiIGZpbGw9IiNFNTcyMDAiLz48cGF0aCBkPSJNMTAxLjM3MSA3Mi43MDlsLTUuMDIzLTE4LjkwMWMyLjg3NC0xLjgzMiA0Ljc4Ni01LjA0IDQuNzg2LTguNzAxIDAtNS43LTQuNjItMTAuMzItMTAuMzItMTAuMzItNS42OTkgMC0xMC4zMTkgNC42Mi0xMC4zMTkgMTAuMzIgMCA1LjY4MiA0LjU5MiAxMC4yODkgMTAuMjY3IDEwLjMxN0w5NS44IDc0LjM3OGMtMTkuNjA5IDYuNTEtNDAuODg1IDIwLjc0Mi00MC44ODUgNTEuODguNDM2IDQ1LjAxIDU5LjU3MiA4NS4yNjcgNzMuMTg2IDg1LjI2N1Y2OC44OTJzLTEyLjI1Mi0uMDYyLTI2LjcyOSAzLjgxN3ptMTAuMzk1IDkyLjA5Yy04LjEzOCAxMC4yLTUyLjczNS0yNS44OC00NS4xNTQtNTEuNjQ1IDMuMDAyLTEyLjE0NSAxMy4xOS0xNy42MTIgMjEuNTExLTE2LjI4IDMwLjM1IDYuMTc1IDM1LjI2IDQ5LjM2OSAyMy42NDMgNjcuOTI2em0tMTguODItMzkuNDZhOS4zOTkgOS4zOTkgMCAwIDAtOS4zOTkgOS4zOTggOS4zOTkgOS4zOTkgMCAwIDAgOS40IDkuNCA5LjM5OSA5LjM5OSAwIDAgMCA5LjM5OC05LjQgOS4zOTkgOS4zOTkgMCAwIDAtOS4zOTktOS4zOTl6bS0yLjgxIDguNjcxYTIuMzc0IDIuMzc0IDAgMSAxIDAtNC43NDggMi4zNzQgMi4zNzQgMCAwIDEgMCA0Ljc0OHoiIGZpbGw9IiNGRjdGMDAiLz48L3N2Zz4=)

# ArduTAP: Simple Library for Working with JTAG TAP

ArduTAP is an Arduino library designed to facilitate communication with devices using the JTAG protocol and based on [ArduJTAG](https://github.com/Zamuhrishka/ArduJTAG) library. It provides an intuitive and straightforward interface for interfacing with JTAG Test Access Ports (TAPs).

## Features

- Simple and easy-to-use API for interacting with JTAG devices.
- Supports basic JTAG operations such as reading from and writing to instruction and data registers.
- Allows setting up and controlling the JTAG communication speed and other parameters.


## Install

- Clone this repository into Arduino/Libraries or use the built-in Arduino IDE Library manager to install a copy of this library.

- Include in your sketch

```c
#include "TAP.hpp"
```

### Install Using PlatformIO

Install ArduTAP using the platformio library manager in your editor, or using the PlatformIO Core CLI, or by adding it to your platformio.ini as shown below:

```shell
[env]
lib_deps =
    ArduTAP
[env]
lib_deps =
    https://github.com/Zamuhrishka/ArduTAP.git
```

## Dependencies

- [ArduJTAG](https://github.com/Zamuhrishka/ArduJTAG)

## Usage

To demonstrate the use of this library, I will show how to interact with the STM32F407 microcontroller via the JTAG interface.
This microcontroller contains 2 TAP modules connected in series: **BoundaryScan** and **Debug**:

![STM32F407TAP](doc/img/STM32F407TAPs.png)

The size of the `IR` register for the **BoundaryScan** TAP is `5` bits. For the **Debug** TAP, it is `4` bits.

### Instruction structure

For current library any JTAG instruction must be rerpresent by next structure:

```c
struct Instruction
{
  uint16_t code;    // Instruction code
  uint16_t ir_len;  // Length of the instruction register
  uint16_t dr_len;  // Length of the data register
};
```

For example if you want to execute `IDCODE` instruction then you need create next variable:

```c
Instruction_s IDCODE = {.code = 0x1FE, .ir_len = 9, .dr_len = 32};
```

And use this variable as argument for TAP methods.


### Read data from the TAP

For reading data, the following function is used:

```c
/**
   * \brief Read data from the device by applying the given instruction and
   * storing the output
   *
   * \param instruction Instruction structure containing the code and lengths
   * \param data Pointer to a buffer where the output data will be stored
   */
  void read(const Instruction_s &instruction, uint8_t *data);
```

The data array will be store readded bits from TAP. Format of this bits are same as for [ArduJTAG](https://github.com/Zamuhrishka/ArduJTAG), please see accordig paragraph of the ArduJTAG `README.md` file.

### Write data to the TAP

For writing data, the following function is used:

```c
/**
   * \brief Write data to the device using the given instruction
   *
   * \param instruction Instruction structure containing the code and lengths
   * \param data Pointer to the data to be written
   */
  void write(const Instruction_s &instruction, /*const*/ uint8_t *data);
```

The data array will be store bits for write to TAP. Format of this bits are same as for [ArduJTAG](https://github.com/Zamuhrishka/ArduJTAG), please see accordig paragraph of the ArduJTAG `README.md` file.

### Execute instruction

For executing, the following function is used:

```c
/**
   * \brief Execute a JTAG operation given an instruction, input data, and an
   * output buffer
   *
   * \param instruction Instruction structure containing the code and lengths
   * \param input Pointer to the input data
   * \param output Pointer to the buffer where the output data will be stored
   */
  void execute(const Instruction_s &instruction, /*const*/ uint8_t *input, uint8_t *output);
```

The main feature of this function is that it give possibility wtite data to the TAP and read data from the TAP in same moment.

### Raw read

If you need just read data from `DR` register without executing any instruction then you need use function:

```c
/**
   * \brief Read raw data of specified length from the device
   *
   * \param input Pointer to the input data
   * \param data Pointer to a buffer where the output data will be stored
   * \param len Length of the data to read
   */
  void read_raw(uint8_t *input, uint8_t *data, uint16_t len);
```

More examples of using this library can be found in [examples](./examples/).

## Contributing

Bug reports and/or pull requests are welcome.

## Disclaimer

This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
